[Back](README.md)

## React

## Redux
- `Стор` це об'єкт, який містить глобальний стан додатка, та декілька методів для взаємодії з ним, наприклад доступу до стану. У програмі може бути лише один стор.
- Для того щоб в компоненті отримати дані зі стору, у бібліотеці React Redux є хук useSelector(selector). Аргументом він приймає функцію (селектор), яка оголошує один параметр state - весь об'єкт стану Redux, який буде автоматично переданий функції хуком useSelector.
- `Екшени` - це об'єкти, які передають дані із компонентів у стор, тим самим сигналізуючи про те, яка подія сталася в додатку. Вони являються єдиним джерелом інформації для стору.
- `Редюсер` (`reducer`) - це функція, яка приймає поточний стан та екшен як аргументи і повертає новий стан. Один із фундаментальних принципів Redux полягає в тому, що редюсери повинні бути чистими функціями, які не змінюють поточний стан, а повертають новий
- Селектори — це функції, які інкапсулюють читання значень з Redux-стану. Вони, як правило, приймають поточний стан Redux і повертають необхідну частину цього стану
___
- Можливість оголошувати асинхронні генератори екшенів та виконувати асинхронні дії надає розширення стора `redux-thunk`, яке за умовчанням включено до Redux Toolkit.
- `Redux Toolkit` має функцію `createAsyncThunk(type, payloadCreator)`, яка допомагає легше працювати з асинхронними запитами. Перший аргумент (type) — це назва екшену, а другий (`payloadCreator`) — функція, що виконує HTTP-запит і повертає дані. Ці дані потім використовуються в `payload`. Функція `createAsyncThunk()` повертає асинхронний екшен, який виконується при запуску, щоб отримати дані з сервера.

## React Q\A

1.	[Для чого потрібен Virtual DOM в React?](#id1)
2.	[Різниця між virtual DOM та shadow DOM?](#id2)
3.	[В чому різниця між state та props?](#id3)
4.	[В чому різниця між класовим та функціональним компонентом?](#id4)
5.	[Які є методи життєвого циклу в React?](#id5)
6.	[Як обновити state в класовому компоненті?](#id6)
7.	[Чому setState - це асинхронна функція?](#id7)
8.	[Що потрібно зробити, щоб компонент обновився?](#id8)
9.	[Як попередити/відмінити лишнє оновлення компоненту?](#id9)
10.	[Що таке PureComponent і в чому його особливість?](#id10)
11.	[Для чого потрібен key?](#id11)
12.	[Для чого потрібен Fragment?](#id12)
13.	[Для чого потрібні портали?](#id13)
14.	[Що таке refs?](#id14)
15.	[Що таке context? Скільки context може бути в проекті?](#id15)
16.	[Для чого потрібні render props?](#id16)
17.	[Для чого потрібні HOCs?](#id17)
18.	[Як реалізувати компонент запобіжника (Error Boundary)?](#id18)
19.	[Які можливості відкривають хуки? Які хуки ви знаєте?](#id19)
20.	[Які правила використання хуків?](#id20)
21.	[Для чого потрібен useEffect?](#id21)
22.	[Чим відрізняється useEffect від useLayoutEffect?](#id22)
23.	[Що таке "линивая" ініціалізація стану в useState і useReducer?](#id23)
24.	[Чим useRef відрізняється від createRef?](#id24)
25.	[Для чого потрібні useMemo та useCallback?](#id25)
26.	[Для чого потрібен redux? Який він має data flow?](#id26)
27.	[Що таке redux middleware?](#id27)
28.	[Де потрібно робити side effects в redux?](#id28)
29.	[Що таке next() функція в redux middleware?](#id29)
30.	[Для чого потрібні redux селектори?](#id30)
31.	[Чим відрізняється action від action creator?](#id31)


#### <a id="id1"></a>Для чого потрібен Virtual DOM в React?
Virtual DOM (віртуальний DOM) — це легка копія реального DOM, яку React використовує для підвищення продуктивності. React оновлює спочатку Virtual DOM, порівнює його з попередньою версією (diffing), і тільки потім вносить мінімальні зміни в реальний DOM.
____
#### <a id="id2"></a>Різниця між Virtual DOM та Shadow DOM
`Virtual DOM` — концепція React, оптимізація оновлення DOM.

`Shadow DOM` — браузерна технологія для інкапсуляції стилів і структури веб-компонентів.
___
#### <a id="id3"></a>Різниця між state та props
`State` — внутрішній стан компонента, можна змінювати.

`Props` — зовнішні дані, що передаються в компонент (не можна змінювати в середині компонента).
___
#### <a id="id4"></a>Різниця між класовим та функціональним компонентом
Класовий компонент: використовує class, має доступ до життєвих циклів.

Функціональний компонент: функція, з React 16.8 може мати стан через хуки.
___
#### <a id="id5"></a>Методи життєвого циклу в React (класи)
- `componentDidMount()`
- `componentDidUpdate(prevProps, prevState)`
- `componentWillUnmount()`
- `shouldComponentUpdate()`
- `getDerivedStateFromProps()`
- `getSnapshotBeforeUpdate()`
___
#### <a id="id6"></a>Як обновити state в класовому компоненті?
```
this.setState({ key: value });
```
___
#### <a id="id7"></a>Чому setState — асинхронна функція?
React оптимізує оновлення і групує виклики setState для покращення продуктивності. Це дозволяє уникати зайвих перерендерів.
___
#### <a id="id8"></a>Що потрібно зробити, щоб компонент обновився?
Змінити state або props.
___
#### <a id="id9"></a>Як попередити/відмінити лишнє оновлення компоненту?
- `shouldComponentUpdate()`
- `React.memo()` (для функціональних компонентів)
- `PureComponent` (для класових)
___
#### <a id="id10"></a>Що таке `PureComponent` і в чому його особливість?
Це класовий компонент, який автоматично реалізує shouldComponentUpdate() з поверхневим порівнянням props і state.
___
#### <a id="id11"></a>Для чого потрібен key?
key допомагає React ефективно оновлювати списки елементів, ідентифікує кожен елемент в масиві.
___
#### <a id="id12"></a>Для чого потрібен Fragment?
Щоб повертати кілька елементів з компонента без зайвого DOM-обгортання.

`<React.Fragment>...</React.Fragment>` або `<>...</>`
___
#### <a id="id13"></a>Для чого потрібні портали?
Для рендерингу дочірніх компонентів за межами DOM-ієрархії батька, наприклад, для модальних вікон.
___
#### <a id="id14"></a>Що таке refs?
Refs дозволяють отримати доступ до DOM-елемента або React-компонента напряму.
___
#### <a id="id15"></a>Що таке context? Скільки context може бути в проекті?
`Context` дозволяє передавати дані через дерево компонентів без `props.`
Кількість `context-ів` не обмежена.
___
#### <a id="id16"></a>Для чого потрібні render props?
Патерн, коли компонент приймає функцію як проп, що повертає JSX — для гнучкого рендеру вмісту.
___
#### <a id="id17"></a>Для чого потрібні HOCs (Higher-Order Components)?
Функції, які приймають компонент і повертають новий компонент з додатковими можливостями (наприклад, авторизація, логування).
___
#### <a id="id18"></a>Як реалізувати компонент запобіжника (Error Boundary)?
```
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // логування
  }

  render() {
    return this.state.hasError ? <h1>Щось пішло не так.</h1> : this.props.children;
  }
}
```
___
#### <a id="id19"></a>Які можливості відкривають хуки? Які хуки ви знаєте?
Хуки дозволяють використовувати стан, ефекти та інші можливості React у функціональних компонентах.
Основні хуки:

- `useState`
- `useEffect`
- `useRef`
- `useContext`
- `useMemo`
- `useCallback`
- `useReducer`
- `useLayoutEffect`
- `useImperativeHandle`
___
#### <a id="id20"></a>Правила використання хуків:

- Використовувати тільки на верхньому рівні функції компонента.
- Не викликати в циклах, умовах, вкладених функціях.
- Використовувати тільки в React-компонентах або кастомних хуках.
___
#### <a id="id21"></a>Для чого потрібен useEffect?
Для виконання побічних ефектів (фетчинг, підписки, зміна DOM). Викликається після рендеру.
___
#### <a id="id22"></a>Чим відрізняється useEffect від useLayoutEffect?
`useEffect` виконується асинхронно після рендеру.

`useLayoutEffect` виконується синхронно до рендеру — підходить, коли зміни потрібно зробити до появи на екрані.
___
#### <a id="id23"></a>Що таке "лінива" ініціалізація стану в `useState` і `useReducer`?
Ініціалізація через функцію, яка виконується один раз при першому рендері:
```
useState(() => важкаФункція());
```
___
#### <a id="id24"></a>Чим useRef відрізняється від createRef?

`useRef` — зберігає значення між рендерами у функціональних компонентах.
`createRef` — створює нову ref при кожному рендері (для класів).
___
#### <a id="id25"></a>Для чого потрібні useMemo та useCallback?
`useMemo` — кешує обчислення.
`useCallback` — кешує функцію, щоб не створювати нову при кожному рендері.
___
#### <a id="id26"></a>Для чого потрібен redux? Який він має data flow?
`Redux` — для централізованого управління станом.
Data flow:
`View` → `Action` → `Reducer` → `Store` → `View`
___
#### <a id="id27"></a>Що таке redux middleware?
Функція, яка перехоплює дії (`actions`) до того, як вони потрапляють у `reducer`. Наприклад: `redux-thunk`, `redux-saga`.
___
#### <a id="id28"></a>Де потрібно робити side effects в redux?
В middleware (наприклад, thunk, saga), а не в редюсерах (вони мають бути чистими функціями).
___
#### <a id="id29"></a>Що таке next() функція в redux middleware?
next() передає action наступному middleware або reducer-у в ланцюгу.
___
#### <a id="id30"></a>Для чого потрібні redux селектори?
Для отримання та обробки даних зі store. Вони покращують продуктивність (можна мемоізувати) і структурують код.
___
#### <a id="id31"></a>Чим відрізняється action від action creator?
`Action` — звичайний об’єкт: { type: 'ADD_TODO', payload: ... }

`Action creator` — функція, яка повертає action:
```
const addTodo = (text) => ({ type: 'ADD_TODO', payload: text });
```


