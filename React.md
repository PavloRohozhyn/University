[Back](README.md)

## React

notes about react


## React Q\A

1.	[Для чого потрібен Virtual DOM в React?](#id1)
2.	[Різниця між virtual DOM та shadow DOM?](#id2)
3.	[В чому різниця між state та props?](#id3)
4.	[В чому різниця між класовим та функціональним компонентом?](#id4)
5.	[Які є методи життєвого циклу в React?](#id5)
6.	[Як обновити state в класовому компоненті?](#id6)
7.	[Чому setState - це асинхронна функція?](#id7)
8.	[Що потрібно зробити, щоб компонент обновився?](#id8)
9.	[Як попередити/відмінити лишнє оновлення компоненту?](#id9)
10.	[Що таке PureComponent і в чому його особливість?](#id10)
11.	[Для чого потрібен key?](#id11)
12.	[Для чого потрібен Fragment?](#id12)
13.	[Для чого потрібні портали?](#id13)
14.	[Що таке refs?](#id14)
15.	[Що таке context? Скільки context може бути в проекті?](#id15)
16.	[Для чого потрібні render props?](#id16)
17.	[Для чого потрібні HOCs?](#id17)
18.	[Як реалізувати компонент запобіжника (Error Boundary)?](#id18)
19.	[Які можливості відкривають хуки? Які хуки ви знаєте?](#id19)
20.	[Які правила використання хуків?](#id20)
21.	[Для чого потрібен useEffect?](#id21)
22.	[Чим відрізняється useEffect від useLayoutEffect?](#id22)
23.	[Що таке "линивая" ініціалізація стану в useState і useReducer?](#id23)
24.	[Чим useRef відрізняється від createRef?](#id24)
25.	[Для чого потрібні useMemo та useCallback?](#id25)
26.	[Для чого потрібен redux? Який він має data flow?](#id26)
27.	[Що таке redux middleware?](#id27)
28.	[Де потрібно робити side effects в redux?](#id28)
29.	[Що таке next() функція в redux middleware?](#id29)
30.	[Для чого потрібні redux селектори?](#id30)
31.	[Чим відрізняється action від action creator?](#id31)


#### <a id="id1"></a>Для чого потрібен Virtual DOM в React?
Virtual DOM (віртуальний DOM) — це легка копія реального DOM, яку React використовує для підвищення продуктивності. React оновлює спочатку Virtual DOM, порівнює його з попередньою версією (diffing), і тільки потім вносить мінімальні зміни в реальний DOM.

#### <a id="id2"></a>Різниця між Virtual DOM та Shadow DOM
`Virtual DOM` — концепція React, оптимізація оновлення DOM.

`Shadow DOM` — браузерна технологія для інкапсуляції стилів і структури веб-компонентів.

#### <a id="id3"></a>Різниця між state та props
`State` — внутрішній стан компонента, можна змінювати.

`Props` — зовнішні дані, що передаються в компонент (не можна змінювати в середині компонента).

#### <a id="id4"></a>Різниця між класовим та функціональним компонентом
Класовий компонент: використовує class, має доступ до життєвих циклів.

Функціональний компонент: функція, з React 16.8 може мати стан через хуки.

#### <a id="id5"></a>Методи життєвого циклу в React (класи)
`componentDidMount()`

`componentDidUpdate(prevProps, prevState)`

`componentWillUnmount()`

`shouldComponentUpdate()`

`getDerivedStateFromProps()`

`getSnapshotBeforeUpdate()`

#### <a id="id6"></a>Як обновити state в класовому компоненті?
```
this.setState({ key: value });
```

#### <a id="id7"></a>Чому setState — асинхронна функція?
React оптимізує оновлення і групує виклики setState для покращення продуктивності. Це дозволяє уникати зайвих перерендерів.

#### <a id="id8"></a>Що потрібно зробити, щоб компонент обновився?

Змінити state або props.

#### <a id="id9"></a>Як попередити/відмінити лишнє оновлення компоненту?

`shouldComponentUpdate()`

`React.memo()` (для функціональних компонентів)

`PureComponent` (для класових)

#### <a id="id10"></a>Що таке `PureComponent` і в чому його особливість?
Це класовий компонент, який автоматично реалізує shouldComponentUpdate() з поверхневим порівнянням props і state.

#### <a id="id11"></a>Для чого потрібен key?
key допомагає React ефективно оновлювати списки елементів, ідентифікує кожен елемент в масиві.

#### <a id="id12"></a>Для чого потрібен Fragment?
Щоб повертати кілька елементів з компонента без зайвого DOM-обгортання.

`<React.Fragment>...</React.Fragment>` або `<>...</>`

#### <a id="id13"></a>Для чого потрібні портали?
Для рендерингу дочірніх компонентів за межами DOM-ієрархії батька, наприклад, для модальних вікон.

#### <a id="id14"></a>Що таке refs?
Refs дозволяють отримати доступ до DOM-елемента або React-компонента напряму.

#### <a id="id15"></a>Що таке context? Скільки context може бути в проекті?
`Context` дозволяє передавати дані через дерево компонентів без `props.`
Кількість `context-ів` не обмежена.

#### <a id="id16"></a>Для чого потрібні render props?
Патерн, коли компонент приймає функцію як проп, що повертає JSX — для гнучкого рендеру вмісту.

#### <a id="id17"></a>Для чого потрібні HOCs (Higher-Order Components)?
Функції, які приймають компонент і повертають новий компонент з додатковими можливостями (наприклад, авторизація, логування).

#### <a id="id18"></a>Як реалізувати компонент запобіжника (Error Boundary)?
```
class ErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    // логування
  }

  render() {
    return this.state.hasError ? <h1>Щось пішло не так.</h1> : this.props.children;
  }
}
```

#### <a id="id19"></a>Які можливості відкривають хуки? Які хуки ви знаєте?

Хуки дозволяють використовувати стан, ефекти та інші можливості React у функціональних компонентах.
Основні хуки:

- `useState`
- `useEffect`
- `useRef`
- `useContext`
- `useMemo`
- `useCallback`
- `useReducer`
- `useLayoutEffect`
- `useImperativeHandle`

#### <a id="id20"></a>Правила використання хуків:

Використовувати тільки на верхньому рівні функції компонента.

Не викликати в циклах, умовах, вкладених функціях.

Використовувати тільки в React-компонентах або кастомних хуках.

#### <a id="id21"></a>Для чого потрібен useEffect?
Для виконання побічних ефектів (фетчинг, підписки, зміна DOM). Викликається після рендеру.

#### <a id="id22"></a>Чим відрізняється useEffect від useLayoutEffect?
`useEffect` виконується асинхронно після рендеру.

`useLayoutEffect` виконується синхронно до рендеру — підходить, коли зміни потрібно зробити до появи на екрані.

#### <a id="id23"></a>Що таке "лінива" ініціалізація стану в `useState` і `useReducer`?
Ініціалізація через функцію, яка виконується один раз при першому рендері:
```
useState(() => важкаФункція());
```

#### <a id="id24"></a>Чим useRef відрізняється від createRef?

`useRef` — зберігає значення між рендерами у функціональних компонентах.
`createRef` — створює нову ref при кожному рендері (для класів).

#### <a id="id25"></a>Для чого потрібні useMemo та useCallback?
`useMemo` — кешує обчислення.
`useCallback` — кешує функцію, щоб не створювати нову при кожному рендері.

#### <a id="id26"></a>Для чого потрібен redux? Який він має data flow?
`Redux` — для централізованого управління станом.
Data flow:
`View` → `Action` → `Reducer` → `Store` → `View`

#### <a id="id27"></a>Що таке redux middleware?
Функція, яка перехоплює дії (`actions`) до того, як вони потрапляють у `reducer`. Наприклад: `redux-thunk`, `redux-saga`.

#### <a id="id28"></a>Де потрібно робити side effects в redux?
В middleware (наприклад, thunk, saga), а не в редюсерах (вони мають бути чистими функціями).

#### <a id="id29"></a>Що таке next() функція в redux middleware?
next() передає action наступному middleware або reducer-у в ланцюгу.

#### <a id="id30"></a>Для чого потрібні redux селектори?
Для отримання та обробки даних зі store. Вони покращують продуктивність (можна мемоізувати) і структурують код.

#### <a id="id31"></a>Чим відрізняється action від action creator?
`Action` — звичайний об’єкт: { type: 'ADD_TODO', payload: ... }

`Action creator` — функція, яка повертає action:
```
const addTodo = (text) => ({ type: 'ADD_TODO', payload: text });
```


