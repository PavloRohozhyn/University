[Back](README.md)

## Java Script


## Java Script Q/A

1	[Типи даних в в JavaScript?](#id1)
2	[Що таке NaN?]
3	[В чому різниця між null та undefined?]
4	[Чим відрізняється строга рівність від не строгої (=== і ==)?]
5	[Логічні оператори !, &&, ||. Як працюють?] 
6	[Що таке use strict і для чого він потрібен?]
7	[Чому результатом порівняння двох схожих обєктів буде false?]
8	[Як перевірити ідентичність 2х обєктів?]
9	[Як зробити копію обєкта?]
10	[Чим відрізняються змінні var, let и const?]
11	[Як дізнатись, чи являються дані масивом?]
12	[Які перебираючі методи масивів ви знаєте?]
13	[Як обєднати масиви?]
14	[Як дізнатись, чи знаходиться елемент в масиві?]
15	[Чи можна використовувати цикл for in для масивів? Які недоліки такого методу?]
16	[Що таке підняття (hoisting)?]
17	[Яким буде значення змінної var при зверненні до неї до її обявлення?]
18	[Що буде, якщо звернутись до змінних let/const до початку їх обявлення?]
19	[Що таке область видимості (Scope)? Яка вона буває?]
20	[Різниця між Function Declaration та Function Expression?]
21	[Що таке callback функції?]
22	[Чим стрілкова функція відрізняється від звичайних функцій?]
23	[Чи є аналог arguments для стрілкових функцій?]
24	[Як визвати функцію із затримкою в 5 секунд?]
25	[Що таке лексичне оточення (Lexical Environment)?]
26	[Що являється глобальним лексичним оточенням?]
27	[Що таке замикання (Closures)? Для чого воно використовується?]
28	[Що таке IIFE?]
29	[Основні принципи ООП?]
30	[Що таке this?]
31	[Як можна змінити контекст виклику функції?]
32	[Чи можна змінити контекст функції, яку повернув метод bind?]
33	[Чи можна змінити контекст стрілкової функції?]
34	[Що таке прототип обєкту?]
35	[Як працює прототипне наслідування в JS?]
36	[Як створити обєкт в якому не буде прототипу?]
37	[Як перевірити, чи являється властивість обєкта його особистою властивістю або це властивість прототипу?]
38	[Чи можна заборонити змінювати властивість прототипу? Як це зробити?]
39	[Чим відрізняється функція конструктор і клас?]
40	[Що потрібно зробити, щоб метод класа потрапив до його екземпляру?]
41	[Що таке LocalStorage та SessionStorage?]
42	[Що таке Promise?]
43	[Для чого потрібен метод Promise.all та Promise.race?]
44	[Що таке async/await і для чого він потрібен?]
45	[Як обробити помилки в async/await?]
46	[Що таке event loop?]
47	[Що таке CRUD?] 



1. Типи даних в JavaScript

    Примітиви: string, number, boolean, null, undefined, symbol, bigint

    Об'єкти: Object, Array, Function, тощо

2. Що таке NaN?

NaN (Not a Number) — результат невдалих математичних операцій, напр. parseInt("abc").
3. Різниця між null і undefined

    undefined: значення змінної, якій нічого не присвоїли

    null: явно вказане "порожнє" значення

4. === vs ==

    ==: порівнює після приведення типів

    ===: строге порівняння — типи й значення мають збігатись

5. Оператори !, &&, ||

    !: логічне заперечення

    &&: логічне І (зупиняється на false)

    ||: логічне АБО (зупиняється на true)

6. Що таке "use strict"?

Активує суворий режим: забороняє неявні дії, допомагає уникати помилок
7. Порівняння об'єктів → false

Бо порівнюється посилання, а не вміст: {} !== {}
8. Як перевірити ідентичність 2х об’єктів?

Object.is(obj1, obj2) або порівняти JSON.stringify (обмеження!)
9. Як зробити копію об’єкта?

    Поверхнева: Object.assign({}, obj) або {...obj}

    Глибока: structuredClone(obj) або через JSON

10. var vs let vs const

    var: функціональна область видимості, піднімається

    let: блочна область, не піднімається

    const: як let, але не дозволяє перевизначення

11. Як дізнатись, чи це масив?

Array.isArray(data)
12. Методи масивів (перебираючі):

forEach, map, filter, reduce, some, every, find, findIndex
13. Як об’єднати масиви?

    array1.concat(array2)

    [...array1, ...array2]

14. Чи є елемент в масиві?

includes(value), indexOf(value) !== -1
15. for...in для масивів?

Можна, але не рекомендується: перебирає всі властивості, не лише елементи.
16. Що таке hoisting (підняття)?

Оголошення змінних і функцій "піднімаються" на початок області видимості
17. var до оголошення:

undefined, бо піднімається, але не ініціалізується
18. let/const до оголошення:

Помилка ReferenceError — вони не ініціалізуються до оголошення
19. Scope (область видимості):

    Глобальна

    Функціональна

    Блочна (для let/const)

20. Function Declaration vs Expression

    Declaration: піднімається

    Expression: ні, створюється під час виконання

21. Callback-функції

Функції, що передаються як аргументи в інші функції
22. Стрілкова vs звичайна функція

    Не мають власного this, arguments, super, new

    Коротший синтаксис

23. arguments у стрілкових функцій?

Немає — використовувати rest-параметри (...args)
24. Затримка 5 секунд:

setTimeout(() => {
  // код
}, 5000);

25. Лексичне оточення (Lexical Environment)

Контекст, у якому оголошена змінна/функція, формується під час написання коду
26. Глобальне лексичне оточення

Оточення, доступне в усьому коді: window (браузер), global (Node.js)
27. Замикання (Closures)

Функції, які "пам’ятають" змінні з оточення, де були створені
28. IIFE (Immediately Invoked Function Expression)

Функція, що виконується одразу після оголошення:

(function() { ... })();

29. Принципи ООП:

    Інкапсуляція

    Наслідування

    Поліморфізм

    Абстракція

30. Що таке this?

Контекст виконання функції (залежить від способу виклику)
31. Як змінити this?

Методи: call(), apply(), bind()
32. Чи змінюється this у функції після bind()?

Ні. bind назавжди прив’язує контекст
33. Контекст у стрілковій функції?

Не можна змінити — this береться з оточення при створенні
34. Прототип об'єкта

Об'єкт, з якого інший об'єкт успадковує властивості
35. Прототипне наслідування

Об'єкти можуть наслідувати властивості через __proto__ або Object.create()
36. Об’єкт без прототипу:

const obj = Object.create(null);

37. Особиста vs прототипна властивість

obj.hasOwnProperty('key') — перевіряє лише власні
38. Заборонити зміну прототипу

Object.freeze(Object.getPrototypeOf(obj));

39. Функція-конструктор vs клас

    Клас — синтаксичний цукор над функцією-конструктором

    Класи не піднімаються

40. Щоб метод класу був у екземплярі:

Прописати його всередині конструктора, але це не рекомендовано — краще в прототипі
41. LocalStorage / SessionStorage

    localStorage: зберігає дані без терміну дії

    sessionStorage: тільки на час сесії вкладки

42. Що таке Promise

Об’єкт для роботи з асинхронними операціями (then, catch, finally)
43. Promise.all vs Promise.race

    Promise.all: чекає всі, або повертає першу помилку

    Promise.race: повертає перший виконаний (успіх чи помилка)

44. async/await

Синтаксичний цукор для зручної роботи з Promise
45. Обробка помилок в async/await

Використовувати try...catch
46. Event Loop

Механізм, який дозволяє асинхронне виконання коду (обробка мікро- і макротасків)
47. CRUD

    Create

    Read

    Update

    Delete
    Операції з даними в базах чи API




