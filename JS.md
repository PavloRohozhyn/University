[Back](README.md)

## Java Script


## Java Script Q/A

1.	[Типи даних в в JavaScript?](#id1)
2.	[Що таке NaN?](#id2)
3.	[В чому різниця між null та undefined?](#id3)
4.	[Чим відрізняється строга рівність від не строгої (=== і ==)?](#id4)
5.	[Логічні оператори !, &&, ||. Як працюють?](#id5) 
6.	[Що таке use strict і для чого він потрібен?](#id6)
7.	[Чому результатом порівняння двох схожих обєктів буде false?](#id7)
8.	[Як перевірити ідентичність 2х обєктів?](#id8)
9.	[Як зробити копію обєкта?](#id9)
10.	[Чим відрізняються змінні var, let и const?](#id10)
11.	[Як дізнатись, чи являються дані масивом?](#id11)
12.	[Які перебираючі методи масивів ви знаєте?](#id12)
13.	[Як обєднати масиви?](#id13)
14.	[Як дізнатись, чи знаходиться елемент в масиві?](#id14)
15.	[Чи можна використовувати цикл for in для масивів? Які недоліки такого методу?](#id15)
16.	[Що таке підняття (hoisting)?](#id16)
17.	[Яким буде значення змінної var при зверненні до неї до її обявлення?](#id17)
18.	[Що буде, якщо звернутись до змінних let/const до початку їх обявлення?](#id18)
19.	[Що таке область видимості (Scope)? Яка вона буває?](#id19)
20.	[Різниця між Function Declaration та Function Expression?](#id20)
21.	[Що таке callback функції?](#id21)
22.	[Чим стрілкова функція відрізняється від звичайних функцій?](#id22)
23.	[Чи є аналог arguments для стрілкових функцій?](#id23)
24.	[Як визвати функцію із затримкою в 5 секунд?](#id24)
25.	[Що таке лексичне оточення (Lexical Environment)?](#id25)
26.	[Що являється глобальним лексичним оточенням?](#id26)
27.	[Що таке замикання (Closures)? Для чого воно використовується?](#id27)
28.	[Що таке IIFE?](#id28)
29.	[Основні принципи ООП?](#id29)
30.	[Що таке this?](#id30)
31.	[Як можна змінити контекст виклику функції?](#id31)
32.	[Чи можна змінити контекст функції, яку повернув метод bind?](#id32)
33.	[Чи можна змінити контекст стрілкової функції?](#id33)
34.	[Що таке прототип обєкту?](#id34)
35.	[Як працює прототипне наслідування в JS?](#id35)
36.	[Як створити обєкт в якому не буде прототипу?](#id36)
37.	[Як перевірити, чи являється властивість обєкта його особистою властивістю або це властивість прототипу?](#id37)
38.	[Чи можна заборонити змінювати властивість прототипу? Як це зробити?](#id38)
39.	[Чим відрізняється функція конструктор і клас?](#id39)
40.	[Що потрібно зробити, щоб метод класа потрапив до його екземпляру?](#id40)
41.	[Що таке LocalStorage та SessionStorage?](#id41)
42.	[Що таке Promise?](#id42)
43.	[Для чого потрібен метод Promise.all та Promise.race?](#id43)
44.	[Що таке async/await і для чого він потрібен?](#id44)
45.	[Як обробити помилки в async/await?](#id45)
46.	[Що таке event loop?](#id46)
47.	[Що таке CRUD?](#id47)


#### <a id="id1"></a>Типи даних в JavaScript   
Примітиви: `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint`

Об'єкти: `Object`, `Array`, `Function`, тощо
___
#### <a id="id2"></a>Що таке NaN?

NaN (Not a Number) — результат невдалих математичних операцій, напр. parseInt("abc").
3. Різниця між null і undefined

    undefined: значення змінної, якій нічого не присвоїли

    null: явно вказане "порожнє" значення

4. === vs ==

    ==: порівнює після приведення типів

    ===: строге порівняння — типи й значення мають збігатись

5. Оператори !, &&, ||

    !: логічне заперечення

    &&: логічне І (зупиняється на false)

    ||: логічне АБО (зупиняється на true)

6. Що таке "use strict"?

Активує суворий режим: забороняє неявні дії, допомагає уникати помилок
7. Порівняння об'єктів → false

Бо порівнюється посилання, а не вміст: {} !== {}
8. Як перевірити ідентичність 2х об’єктів?

Object.is(obj1, obj2) або порівняти JSON.stringify (обмеження!)
9. Як зробити копію об’єкта?

    Поверхнева: Object.assign({}, obj) або {...obj}

    Глибока: structuredClone(obj) або через JSON

10. var vs let vs const

    var: функціональна область видимості, піднімається

    let: блочна область, не піднімається

    const: як let, але не дозволяє перевизначення

11. Як дізнатись, чи це масив?

Array.isArray(data)
12. Методи масивів (перебираючі):

forEach, map, filter, reduce, some, every, find, findIndex
13. Як об’єднати масиви?

    array1.concat(array2)

    [...array1, ...array2]

14. Чи є елемент в масиві?

includes(value), indexOf(value) !== -1
15. for...in для масивів?

Можна, але не рекомендується: перебирає всі властивості, не лише елементи.
16. Що таке hoisting (підняття)?

Оголошення змінних і функцій "піднімаються" на початок області видимості
17. var до оголошення:

undefined, бо піднімається, але не ініціалізується
18. let/const до оголошення:

Помилка ReferenceError — вони не ініціалізуються до оголошення
19. Scope (область видимості):

    Глобальна

    Функціональна

    Блочна (для let/const)

20. Function Declaration vs Expression

    Declaration: піднімається

    Expression: ні, створюється під час виконання

21. Callback-функції

Функції, що передаються як аргументи в інші функції
22. Стрілкова vs звичайна функція

    Не мають власного this, arguments, super, new

    Коротший синтаксис

23. arguments у стрілкових функцій?

Немає — використовувати rest-параметри (...args)
24. Затримка 5 секунд:

setTimeout(() => {
  // код
}, 5000);

25. Лексичне оточення (Lexical Environment)

Контекст, у якому оголошена змінна/функція, формується під час написання коду
26. Глобальне лексичне оточення

Оточення, доступне в усьому коді: window (браузер), global (Node.js)
27. Замикання (Closures)

Функції, які "пам’ятають" змінні з оточення, де були створені
28. IIFE (Immediately Invoked Function Expression)

Функція, що виконується одразу після оголошення:

(function() { ... })();

29. Принципи ООП:

    Інкапсуляція

    Наслідування

    Поліморфізм

    Абстракція

30. Що таке this?

Контекст виконання функції (залежить від способу виклику)
31. Як змінити this?

Методи: call(), apply(), bind()
32. Чи змінюється this у функції після bind()?

Ні. bind назавжди прив’язує контекст
33. Контекст у стрілковій функції?

Не можна змінити — this береться з оточення при створенні
34. Прототип об'єкта

Об'єкт, з якого інший об'єкт успадковує властивості
35. Прототипне наслідування

Об'єкти можуть наслідувати властивості через __proto__ або Object.create()
36. Об’єкт без прототипу:

const obj = Object.create(null);

37. Особиста vs прототипна властивість

obj.hasOwnProperty('key') — перевіряє лише власні
38. Заборонити зміну прототипу

Object.freeze(Object.getPrototypeOf(obj));

39. Функція-конструктор vs клас

    Клас — синтаксичний цукор над функцією-конструктором

    Класи не піднімаються

40. Щоб метод класу був у екземплярі:

Прописати його всередині конструктора, але це не рекомендовано — краще в прототипі
41. LocalStorage / SessionStorage

    localStorage: зберігає дані без терміну дії

    sessionStorage: тільки на час сесії вкладки

42. Що таке Promise

Об’єкт для роботи з асинхронними операціями (then, catch, finally)
43. Promise.all vs Promise.race

    Promise.all: чекає всі, або повертає першу помилку

    Promise.race: повертає перший виконаний (успіх чи помилка)

44. async/await

Синтаксичний цукор для зручної роботи з Promise
45. Обробка помилок в async/await

Використовувати try...catch
46. Event Loop

Механізм, який дозволяє асинхронне виконання коду (обробка мікро- і макротасків)
47. CRUD

    Create

    Read

    Update

    Delete
    Операції з даними в базах чи API




